// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: admin.sql

package datastore

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const adminDeleteURL = `-- name: AdminDeleteURL :exec
DELETE FROM urls
WHERE id = $1
`

func (q *Queries) AdminDeleteURL(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, adminDeleteURL, id)
	return err
}

const adminGetDailyActiveVisitors = `-- name: AdminGetDailyActiveVisitors :many
WITH date_series AS (
    SELECT generate_series(
        (CURRENT_DATE - interval '6 days')::date,
        CURRENT_DATE::date,
        '1 day'::interval
    )::date AS day
)
SELECT
    ds.day::timestamp AS "day",
    COUNT(DISTINCT v.ip_address)::bigint AS count
FROM
    date_series ds
LEFT JOIN
    visits v ON date_trunc('day', v.visited_at) = ds.day
GROUP BY
    ds.day
ORDER BY
    ds.day
`

type AdminGetDailyActiveVisitorsRow struct {
	Day   pgtype.Timestamp `json:"day"`
	Count int64            `json:"count"`
}

func (q *Queries) AdminGetDailyActiveVisitors(ctx context.Context) ([]AdminGetDailyActiveVisitorsRow, error) {
	rows, err := q.db.Query(ctx, adminGetDailyActiveVisitors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminGetDailyActiveVisitorsRow{}
	for rows.Next() {
		var i AdminGetDailyActiveVisitorsRow
		if err := rows.Scan(&i.Day, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetGeoDistribution = `-- name: AdminGetGeoDistribution :many
SELECT
    COALESCE(vl.country_name, 'Unknown') AS country,
    COUNT(*)::bigint AS count
FROM
    visits v
JOIN
    visit_locations vl ON v.id = vl.visit_id
GROUP BY
    country
ORDER BY
    count DESC
LIMIT 5
`

type AdminGetGeoDistributionRow struct {
	Country string `json:"country"`
	Count   int64  `json:"count"`
}

func (q *Queries) AdminGetGeoDistribution(ctx context.Context) ([]AdminGetGeoDistributionRow, error) {
	rows, err := q.db.Query(ctx, adminGetGeoDistribution)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminGetGeoDistributionRow{}
	for rows.Next() {
		var i AdminGetGeoDistributionRow
		if err := rows.Scan(&i.Country, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetOverviewStatistics = `-- name: AdminGetOverviewStatistics :one
WITH monthly_user_activity AS (
    SELECT
        SUM(CASE WHEN created_at >= date_trunc('month', CURRENT_DATE) AND created_at < (date_trunc('month', CURRENT_DATE) + interval '1 month') THEN 1 ELSE 0 END) AS new_users_current_month,
        SUM(CASE WHEN created_at >= (date_trunc('month', CURRENT_DATE) - interval '1 month') AND created_at < date_trunc('month', CURRENT_DATE) THEN 1 ELSE 0 END) AS new_users_previous_month
    FROM users
), monthly_url_activity AS (
    SELECT
        SUM(CASE WHEN created_at >= date_trunc('month', CURRENT_DATE) AND created_at < (date_trunc('month', CURRENT_DATE) + interval '1 month') THEN 1 ELSE 0 END) AS new_urls_current_month,
        SUM(CASE WHEN created_at >= (date_trunc('month', CURRENT_DATE) - interval '1 month') AND created_at < date_trunc('month', CURRENT_DATE) THEN 1 ELSE 0 END) AS new_urls_previous_month
    FROM urls
), monthly_visit_activity AS (
    SELECT
        SUM(CASE WHEN visited_at >= date_trunc('month', CURRENT_DATE) AND visited_at < (date_trunc('month', CURRENT_DATE) + interval '1 month') THEN 1 ELSE 0 END) AS new_visits_current_month,
        SUM(CASE WHEN visited_at >= (date_trunc('month', CURRENT_DATE) - interval '1 month') AND visited_at < date_trunc('month', CURRENT_DATE) THEN 1 ELSE 0 END) AS new_visits_previous_month
    FROM visits
)
SELECT
    (SELECT COUNT(*) FROM users) AS total_users,
    (SELECT COUNT(*) FROM urls) AS total_urls,
    (SELECT COUNT(*) FROM visits) AS total_clicks,
    CASE
        WHEN mua.new_users_previous_month = 0 THEN
            CASE
                WHEN mua.new_users_current_month > 0 THEN 100.0 -- Indicate growth from zero
                ELSE 0.0 -- No change from zero
            END
        ELSE (CAST(mua.new_users_current_month AS REAL) - mua.new_users_previous_month) * 100.0 / mua.new_users_previous_month
    END AS total_users_variation,
    CASE
        WHEN mula.new_urls_previous_month = 0 THEN
            CASE
                WHEN mula.new_urls_current_month > 0 THEN 100.0
                ELSE 0.0
            END
        ELSE (CAST(mula.new_urls_current_month AS REAL) - mula.new_urls_previous_month) * 100.0 / mula.new_urls_previous_month
    END AS total_urls_variation,
    CASE
        WHEN mva.new_visits_previous_month = 0 THEN
            CASE
                WHEN mva.new_visits_current_month > 0 THEN 100.0
                ELSE 0.0
            END
        ELSE (CAST(mva.new_visits_current_month AS REAL) - mva.new_visits_previous_month) * 100.0 / mva.new_visits_previous_month
    END AS total_clicks_variation
FROM
    monthly_user_activity mua,
    monthly_url_activity mula,
    monthly_visit_activity mva
`

type AdminGetOverviewStatisticsRow struct {
	TotalUsers           int64       `json:"total_users"`
	TotalUrls            int64       `json:"total_urls"`
	TotalClicks          int64       `json:"total_clicks"`
	TotalUsersVariation  interface{} `json:"total_users_variation"`
	TotalUrlsVariation   interface{} `json:"total_urls_variation"`
	TotalClicksVariation interface{} `json:"total_clicks_variation"`
}

func (q *Queries) AdminGetOverviewStatistics(ctx context.Context) (AdminGetOverviewStatisticsRow, error) {
	row := q.db.QueryRow(ctx, adminGetOverviewStatistics)
	var i AdminGetOverviewStatisticsRow
	err := row.Scan(
		&i.TotalUsers,
		&i.TotalUrls,
		&i.TotalClicks,
		&i.TotalUsersVariation,
		&i.TotalUrlsVariation,
		&i.TotalClicksVariation,
	)
	return i, err
}

const adminGetTopReferrers = `-- name: AdminGetTopReferrers :many
SELECT
    COALESCE(NULLIF(referrer, ''), 'Direct') AS source,
    COUNT(*)::bigint AS count
FROM
    visits
GROUP BY
    source
ORDER BY
    count DESC
LIMIT 5
`

type AdminGetTopReferrersRow struct {
	Source interface{} `json:"source"`
	Count  int64       `json:"count"`
}

func (q *Queries) AdminGetTopReferrers(ctx context.Context) ([]AdminGetTopReferrersRow, error) {
	rows, err := q.db.Query(ctx, adminGetTopReferrers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminGetTopReferrersRow{}
	for rows.Next() {
		var i AdminGetTopReferrersRow
		if err := rows.Scan(&i.Source, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetTopURLs = `-- name: AdminGetTopURLs :many
SELECT
    u.short_url,
    u.long_url,
    COUNT(v.id)::bigint AS clicks
FROM
    urls u
JOIN
    visits v ON u.id = v.url_id
GROUP BY
    u.id
ORDER BY
    clicks DESC
LIMIT 5
`

type AdminGetTopURLsRow struct {
	ShortUrl string `json:"short_url"`
	LongUrl  string `json:"long_url"`
	Clicks   int64  `json:"clicks"`
}

func (q *Queries) AdminGetTopURLs(ctx context.Context) ([]AdminGetTopURLsRow, error) {
	rows, err := q.db.Query(ctx, adminGetTopURLs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminGetTopURLsRow{}
	for rows.Next() {
		var i AdminGetTopURLsRow
		if err := rows.Scan(&i.ShortUrl, &i.LongUrl, &i.Clicks); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetTotalUsersTrend = `-- name: AdminGetTotalUsersTrend :many
WITH date_series AS (
    SELECT generate_series(
        (CURRENT_DATE - interval '29 days')::date, -- Start 30 days ago (inclusive of today)
        CURRENT_DATE::date,                        -- End today
        '1 day'::interval
    )::date AS day
)
SELECT
    ds.day::timestamp AS "day",
    (
        SELECT COUNT(*)
        FROM users u
        WHERE date_trunc('day', u.created_at) <= ds.day
    )::bigint AS count
FROM
    date_series ds
ORDER BY
    ds.day
`

type AdminGetTotalUsersTrendRow struct {
	Day   pgtype.Timestamp `json:"day"`
	Count int64            `json:"count"`
}

func (q *Queries) AdminGetTotalUsersTrend(ctx context.Context) ([]AdminGetTotalUsersTrendRow, error) {
	rows, err := q.db.Query(ctx, adminGetTotalUsersTrend)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminGetTotalUsersTrendRow{}
	for rows.Next() {
		var i AdminGetTotalUsersTrendRow
		if err := rows.Scan(&i.Day, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetURLCreationTrends = `-- name: AdminGetURLCreationTrends :many
WITH date_series AS (
    SELECT generate_series(
        (CURRENT_DATE - interval '29 days')::date, -- Start 30 days ago (inclusive of today)
        CURRENT_DATE::date,                        -- End today
        '1 day'::interval
    )::date AS day
)
SELECT
    ds.day ::timestamp AS "day",
    COALESCE(COUNT(u.created_at), 0)::bigint  AS count
FROM
    date_series ds
LEFT JOIN
    urls u ON date_trunc('day', u.created_at) = ds.day
GROUP BY
    ds.day
ORDER BY
    ds.day
`

type AdminGetURLCreationTrendsRow struct {
	Day   pgtype.Timestamp `json:"day"`
	Count int64            `json:"count"`
}

func (q *Queries) AdminGetURLCreationTrends(ctx context.Context) ([]AdminGetURLCreationTrendsRow, error) {
	rows, err := q.db.Query(ctx, adminGetURLCreationTrends)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminGetURLCreationTrendsRow{}
	for rows.Next() {
		var i AdminGetURLCreationTrendsRow
		if err := rows.Scan(&i.Day, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetUserGrowth = `-- name: AdminGetUserGrowth :many
WITH date_series AS (
    SELECT generate_series(
        (CURRENT_DATE - interval '29 days')::date, -- Start 30 days ago (inclusive of today)
        CURRENT_DATE::date,                        -- End today
        '1 day'::interval
    )::date AS day
)
SELECT
    ds.day ::timestamp AS "day",
    COALESCE(COUNT(u.created_at), 0)::bigint AS count
FROM
    date_series ds
LEFT JOIN
    users u ON date_trunc('day', u.created_at) = ds.day
GROUP BY
    ds.day
ORDER BY
    ds.day
`

type AdminGetUserGrowthRow struct {
	Day   pgtype.Timestamp `json:"day"`
	Count int64            `json:"count"`
}

func (q *Queries) AdminGetUserGrowth(ctx context.Context) ([]AdminGetUserGrowthRow, error) {
	rows, err := q.db.Query(ctx, adminGetUserGrowth)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminGetUserGrowthRow{}
	for rows.Next() {
		var i AdminGetUserGrowthRow
		if err := rows.Scan(&i.Day, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListURLSDetails = `-- name: AdminListURLSDetails :many
SELECT
    urls.id, urls.short_url, urls.long_url, urls.author_id, urls.created_at, urls.title, urls.is_archived,
    users.id, users.username, users.email, users.created_at, users.is_oauth, users.guid, users.updated_at,
    users.username AS author_name,
    COUNT(visits.id) AS click_count
FROM
    urls
JOIN
    users ON urls.author_id = users.id
LEFT JOIN
    visits ON urls.id = visits.url_id
GROUP BY
    urls.id, users.username, users.id
ORDER BY
    urls.created_at DESC
`

type AdminListURLSDetailsRow struct {
	Url        Url    `json:"url"`
	User       User   `json:"user"`
	AuthorName string `json:"author_name"`
	ClickCount int64  `json:"click_count"`
}

func (q *Queries) AdminListURLSDetails(ctx context.Context) ([]AdminListURLSDetailsRow, error) {
	rows, err := q.db.Query(ctx, adminListURLSDetails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminListURLSDetailsRow{}
	for rows.Next() {
		var i AdminListURLSDetailsRow
		if err := rows.Scan(
			&i.Url.ID,
			&i.Url.ShortUrl,
			&i.Url.LongUrl,
			&i.Url.AuthorID,
			&i.Url.CreatedAt,
			&i.Url.Title,
			&i.Url.IsArchived,
			&i.User.ID,
			&i.User.Username,
			&i.User.Email,
			&i.User.CreatedAt,
			&i.User.IsOauth,
			&i.User.Guid,
			&i.User.UpdatedAt,
			&i.AuthorName,
			&i.ClickCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListUsers = `-- name: AdminListUsers :many
SELECT
    u.id, u.username, u.email, u.created_at, u.is_oauth, u.guid, u.updated_at,
    COALESCE(s.stripe_product_name, 'Free') AS plan_name,
    COUNT(DISTINCT urls.id) AS url_count,
    COUNT(DISTINCT v.id) AS click_count,
    'active' AS user_status
FROM
    users u
LEFT JOIN
    customer c ON u.guid = c.user_id
LEFT JOIN
    subscription s ON c.user_id = s.customer_id
LEFT JOIN
    urls ON u.id = urls.author_id
LEFT JOIN
    visits v ON urls.id = v.url_id
GROUP BY
    u.id, u.username, u.email, u.created_at, s.stripe_product_name, s.status
ORDER BY
    u.created_at DESC
`

type AdminListUsersRow struct {
	ID         int32            `json:"id"`
	Username   string           `json:"username"`
	Email      string           `json:"email"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	IsOauth    pgtype.Bool      `json:"is_oauth"`
	Guid       pgtype.UUID      `json:"guid"`
	UpdatedAt  pgtype.Timestamp `json:"updated_at"`
	PlanName   string           `json:"plan_name"`
	UrlCount   int64            `json:"url_count"`
	ClickCount int64            `json:"click_count"`
	UserStatus string           `json:"user_status"`
}

func (q *Queries) AdminListUsers(ctx context.Context) ([]AdminListUsersRow, error) {
	rows, err := q.db.Query(ctx, adminListUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminListUsersRow{}
	for rows.Next() {
		var i AdminListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.CreatedAt,
			&i.IsOauth,
			&i.Guid,
			&i.UpdatedAt,
			&i.PlanName,
			&i.UrlCount,
			&i.ClickCount,
			&i.UserStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminUpdateURL = `-- name: AdminUpdateURL :one
UPDATE urls
SET title = $1,
    long_url = $2
WHERE id = $3
RETURNING id, short_url, long_url, author_id, created_at, title, is_archived
`

type AdminUpdateURLParams struct {
	Title   string `json:"title"`
	LongUrl string `json:"long_url"`
	ID      int32  `json:"id"`
}

func (q *Queries) AdminUpdateURL(ctx context.Context, arg AdminUpdateURLParams) (Url, error) {
	row := q.db.QueryRow(ctx, adminUpdateURL, arg.Title, arg.LongUrl, arg.ID)
	var i Url
	err := row.Scan(
		&i.ID,
		&i.ShortUrl,
		&i.LongUrl,
		&i.AuthorID,
		&i.CreatedAt,
		&i.Title,
		&i.IsArchived,
	)
	return i, err
}

const adminUpdateURLStatus = `-- name: AdminUpdateURLStatus :exec
UPDATE urls
SET is_archived = $1
WHERE id = $2
`

type AdminUpdateURLStatusParams struct {
	IsArchived pgtype.Bool `json:"is_archived"`
	ID         int32       `json:"id"`
}

func (q *Queries) AdminUpdateURLStatus(ctx context.Context, arg AdminUpdateURLStatusParams) error {
	_, err := q.db.Exec(ctx, adminUpdateURLStatus, arg.IsArchived, arg.ID)
	return err
}

const isAdmin = `-- name: IsAdmin :one
SELECT
    EXISTS (
        SELECT 1
        FROM users
        JOIN user_roles
          ON users.guid = user_roles.user_id
        WHERE guid = $1 AND role = 'admin'
    ) AS is_admin
`

func (q *Queries) IsAdmin(ctx context.Context, guid pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, isAdmin, guid)
	var is_admin bool
	err := row.Scan(&is_admin)
	return is_admin, err
}
