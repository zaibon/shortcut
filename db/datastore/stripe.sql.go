// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: stripe.sql

package datastore

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCustomer = `-- name: GetCustomer :one
SELECT user_id, stripe_id, created_at, updated_at
FROM customer
WHERE user_id = $1
LIMIT 1
`

func (q *Queries) GetCustomer(ctx context.Context, userID pgtype.UUID) (Customer, error) {
	row := q.db.QueryRow(ctx, getCustomer, userID)
	var i Customer
	err := row.Scan(
		&i.UserID,
		&i.StripeID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCustomerByStripeId = `-- name: GetCustomerByStripeId :one
SELECT user_id, stripe_id, created_at, updated_at 
FROM customer
WHERE stripe_id = $1
LIMIT 1
`

// Description: Get customer by stripe id
func (q *Queries) GetCustomerByStripeId(ctx context.Context, stripeID string) (Customer, error) {
	row := q.db.QueryRow(ctx, getCustomerByStripeId, stripeID)
	var i Customer
	err := row.Scan(
		&i.UserID,
		&i.StripeID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertCustomer = `-- name: InsertCustomer :one
INSERT INTO customer (user_id, stripe_id)
VALUES ($1, $2)
RETURNING user_id, stripe_id, created_at, updated_at
`

type InsertCustomerParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	StripeID string      `json:"stripe_id"`
}

func (q *Queries) InsertCustomer(ctx context.Context, arg InsertCustomerParams) (Customer, error) {
	row := q.db.QueryRow(ctx, insertCustomer, arg.UserID, arg.StripeID)
	var i Customer
	err := row.Scan(
		&i.UserID,
		&i.StripeID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertSubscription = `-- name: InsertSubscription :one
INSERT INTO subscription (stripe_id, customer_id, stripe_price_id, stripe_product_name, status, quantity)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING stripe_id, customer_id, stripe_price_id, stripe_product_name, status, quantity, created_at, updated_at
`

type InsertSubscriptionParams struct {
	StripeID          string      `json:"stripe_id"`
	CustomerID        pgtype.UUID `json:"customer_id"`
	StripePriceID     string      `json:"stripe_price_id"`
	StripeProductName string      `json:"stripe_product_name"`
	Status            string      `json:"status"`
	Quantity          int32       `json:"quantity"`
}

func (q *Queries) InsertSubscription(ctx context.Context, arg InsertSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, insertSubscription,
		arg.StripeID,
		arg.CustomerID,
		arg.StripePriceID,
		arg.StripeProductName,
		arg.Status,
		arg.Quantity,
	)
	var i Subscription
	err := row.Scan(
		&i.StripeID,
		&i.CustomerID,
		&i.StripePriceID,
		&i.StripeProductName,
		&i.Status,
		&i.Quantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCustomerSubscription = `-- name: ListCustomerSubscription :many
SELECT stripe_id, customer_id, stripe_price_id, stripe_product_name, status, quantity, created_at, updated_at
FROM subscription
WHERE customer_id = $1
AND ($2::text IS NULL OR $2 = status)
ORDER BY updated_at DESC
`

type ListCustomerSubscriptionParams struct {
	CustomerID pgtype.UUID `json:"customer_id"`
	Status     pgtype.Text `json:"status"`
}

func (q *Queries) ListCustomerSubscription(ctx context.Context, arg ListCustomerSubscriptionParams) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listCustomerSubscription, arg.CustomerID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.StripeID,
			&i.CustomerID,
			&i.StripePriceID,
			&i.StripeProductName,
			&i.Status,
			&i.Quantity,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubscription = `-- name: UpdateSubscription :one
UPDATE subscription
SET status = $2, stripe_price_id = $3, stripe_product_name = $4, quantity = $5
WHERE stripe_id = $1
RETURNING stripe_id, customer_id, stripe_price_id, stripe_product_name, status, quantity, created_at, updated_at
`

type UpdateSubscriptionParams struct {
	StripeID          string `json:"stripe_id"`
	Status            string `json:"status"`
	StripePriceID     string `json:"stripe_price_id"`
	StripeProductName string `json:"stripe_product_name"`
	Quantity          int32  `json:"quantity"`
}

func (q *Queries) UpdateSubscription(ctx context.Context, arg UpdateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, updateSubscription,
		arg.StripeID,
		arg.Status,
		arg.StripePriceID,
		arg.StripeProductName,
		arg.Quantity,
	)
	var i Subscription
	err := row.Scan(
		&i.StripeID,
		&i.CustomerID,
		&i.StripePriceID,
		&i.StripeProductName,
		&i.Status,
		&i.Quantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
