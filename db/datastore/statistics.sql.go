// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: statistics.sql

package datastore

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const insertVisitLocation = `-- name: InsertVisitLocation :one
INSERT INTO visit_locations (
	visit_id,
	address,
	country_code,
	country_name,
	subdivision,
	continent,
	city_name,
	latitude,
	longitude,
	source
)
VALUES (
	$1,
	$2,
	$3,
	$4,
	$5,
	$6,
	$7,
	$8,
	$9,
	$10
)
RETURNING visit_id, address, country_code, country_name, subdivision, continent, city_name, latitude, longitude, source
`

type InsertVisitLocationParams struct {
	VisitID     int32         `json:"visit_id"`
	Address     pgtype.Text   `json:"address"`
	CountryCode pgtype.Text   `json:"country_code"`
	CountryName pgtype.Text   `json:"country_name"`
	Subdivision pgtype.Text   `json:"subdivision"`
	Continent   pgtype.Text   `json:"continent"`
	CityName    pgtype.Text   `json:"city_name"`
	Latitude    pgtype.Float8 `json:"latitude"`
	Longitude   pgtype.Float8 `json:"longitude"`
	Source      pgtype.Text   `json:"source"`
}

func (q *Queries) InsertVisitLocation(ctx context.Context, arg InsertVisitLocationParams) (VisitLocation, error) {
	row := q.db.QueryRow(ctx, insertVisitLocation,
		arg.VisitID,
		arg.Address,
		arg.CountryCode,
		arg.CountryName,
		arg.Subdivision,
		arg.Continent,
		arg.CityName,
		arg.Latitude,
		arg.Longitude,
		arg.Source,
	)
	var i VisitLocation
	err := row.Scan(
		&i.VisitID,
		&i.Address,
		&i.CountryCode,
		&i.CountryName,
		&i.Subdivision,
		&i.Continent,
		&i.CityName,
		&i.Latitude,
		&i.Longitude,
		&i.Source,
	)
	return i, err
}

const listStatisticsPerAuthor = `-- name: ListStatisticsPerAuthor :many
SELECT
	count(v.id) as nr_visits,
	MIN(u.id)::INTEGER as id,
	u.short_url as short_url,
	MIN(u.long_url):: TEXT as long_url,
	MIN(u.created_at)::TIMESTAMP as created_at
FROM
	urls u
LEFT JOIN visits v ON u.id = v.url_id
WHERE
	u.author_id = $1
GROUP BY
	u.short_url, u.id
ORDER BY
	u.id DESC
`

type ListStatisticsPerAuthorRow struct {
	NrVisits  int64            `json:"nr_visits"`
	ID        int32            `json:"id"`
	ShortUrl  string           `json:"short_url"`
	LongUrl   string           `json:"long_url"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) ListStatisticsPerAuthor(ctx context.Context, authorID pgtype.Int4) ([]ListStatisticsPerAuthorRow, error) {
	rows, err := q.db.Query(ctx, listStatisticsPerAuthor, authorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListStatisticsPerAuthorRow{}
	for rows.Next() {
		var i ListStatisticsPerAuthorRow
		if err := rows.Scan(
			&i.NrVisits,
			&i.ID,
			&i.ShortUrl,
			&i.LongUrl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVisits = `-- name: ListVisits :many
SELECT id, url_id, visited_at, ip_address, user_agent
FROM visits
ORDER BY id DESC
`

func (q *Queries) ListVisits(ctx context.Context) ([]Visit, error) {
	rows, err := q.db.Query(ctx, listVisits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Visit{}
	for rows.Next() {
		var i Visit
		if err := rows.Scan(
			&i.ID,
			&i.UrlID,
			&i.VisitedAt,
			&i.IpAddress,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const statisticPerURL = `-- name: StatisticPerURL :one
SELECT
	count(v.id) as nr_visits,
	MIN(u.id)::INTEGER as id,
	u.short_url as short_url,
	MIN(u.long_url):: TEXT as long_url,
	MIN(u.created_at)::TIMESTAMP as created_at
FROM
	urls u
LEFT JOIN visits v ON u.id = v.url_id
WHERE
	u.short_url = $1
	AND u.author_id = $2
GROUP BY
	u.short_url, u.id
LIMIT 1
`

type StatisticPerURLParams struct {
	ShortUrl string      `json:"short_url"`
	AuthorID pgtype.Int4 `json:"author_id"`
}

type StatisticPerURLRow struct {
	NrVisits  int64            `json:"nr_visits"`
	ID        int32            `json:"id"`
	ShortUrl  string           `json:"short_url"`
	LongUrl   string           `json:"long_url"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) StatisticPerURL(ctx context.Context, arg StatisticPerURLParams) (StatisticPerURLRow, error) {
	row := q.db.QueryRow(ctx, statisticPerURL, arg.ShortUrl, arg.AuthorID)
	var i StatisticPerURLRow
	err := row.Scan(
		&i.NrVisits,
		&i.ID,
		&i.ShortUrl,
		&i.LongUrl,
		&i.CreatedAt,
	)
	return i, err
}

const trackRedirect = `-- name: TrackRedirect :one
INSERT INTO visits (url_id, ip_address, user_agent)
VALUES ($1, $2, $3)
RETURNING id, url_id, visited_at, ip_address, user_agent
`

type TrackRedirectParams struct {
	UrlID     pgtype.Int4 `json:"url_id"`
	IpAddress pgtype.Text `json:"ip_address"`
	UserAgent pgtype.Text `json:"user_agent"`
}

func (q *Queries) TrackRedirect(ctx context.Context, arg TrackRedirectParams) (Visit, error) {
	row := q.db.QueryRow(ctx, trackRedirect, arg.UrlID, arg.IpAddress, arg.UserAgent)
	var i Visit
	err := row.Scan(
		&i.ID,
		&i.UrlID,
		&i.VisitedAt,
		&i.IpAddress,
		&i.UserAgent,
	)
	return i, err
}
