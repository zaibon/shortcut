// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: statistics.sql

package datastore

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const browserDistribution = `-- name: BrowserDistribution :many
SELECT
	browsers.name,
	browsers.version,
	browsers.platform,
  	browsers.mobile,
    count(v.id) AS visit_count,
    (count(v.id) * 100.0 / total_visits.total)::float AS percentage
FROM
    visits v
JOIN
    urls u ON v.url_id = u.id
LEFT JOIN 
	browsers ON browsers.id = v.browser_id
CROSS JOIN (
  SELECT count(*) AS total
  FROM visits
  JOIN urls ON urls.id = visits.url_id
  WHERE urls.id = $1
) AS total_visits
WHERE
	u.author_id = $2
AND
    u.id = $1
GROUP BY
    browsers.name, 
    browsers.version, 
    browsers.platform, 
    browsers.mobile, 
    total_visits.total
ORDER BY
    visit_count DESC
`

type BrowserDistributionParams struct {
	UrlID    int32 `json:"url_id"`
	AuthorID int32 `json:"author_id"`
}

type BrowserDistributionRow struct {
	Name       pgtype.Text `json:"name"`
	Version    pgtype.Text `json:"version"`
	Platform   pgtype.Text `json:"platform"`
	Mobile     pgtype.Bool `json:"mobile"`
	VisitCount int64       `json:"visit_count"`
	Percentage float64     `json:"percentage"`
}

// SQL query to get the distribution of browsers for a specific URL
func (q *Queries) BrowserDistribution(ctx context.Context, arg BrowserDistributionParams) ([]BrowserDistributionRow, error) {
	rows, err := q.db.Query(ctx, browserDistribution, arg.UrlID, arg.AuthorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BrowserDistributionRow{}
	for rows.Next() {
		var i BrowserDistributionRow
		if err := rows.Scan(
			&i.Name,
			&i.Version,
			&i.Platform,
			&i.Mobile,
			&i.VisitCount,
			&i.Percentage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countTotalVisitThisMonth = `-- name: CountTotalVisitThisMonth :one
SELECT count(visits.*)
FROM visits
JOIN urls ON urls.id = visits.url_id
WHERE urls.author_id = $1
AND created_at BETWEEN date_trunc('month', CURRENT_DATE) AND date_trunc('month', CURRENT_DATE) + INTERVAL '1 month'
`

func (q *Queries) CountTotalVisitThisMonth(ctx context.Context, authorID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countTotalVisitThisMonth, authorID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countURLThisMonth = `-- name: CountURLThisMonth :one
SELECT count(*)
FROM urls
WHERE author_id = $1
AND created_at BETWEEN date_trunc('month', CURRENT_DATE) AND date_trunc('month', CURRENT_DATE) + INTERVAL '1 month'
`

func (q *Queries) CountURLThisMonth(ctx context.Context, authorID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countURLThisMonth, authorID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const insertVisitLocation = `-- name: InsertVisitLocation :one
INSERT INTO visit_locations (
	visit_id,
	address,
	country_code,
	country_name,
	subdivision,
	continent,
	city_name,
	latitude,
	longitude,
	source
)
VALUES (
	$1,
	$2,
	$3,
	$4,
	$5,
	$6,
	$7,
	$8,
	$9,
	$10
)
RETURNING visit_id, address, country_code, country_name, subdivision, continent, city_name, latitude, longitude, source
`

type InsertVisitLocationParams struct {
	VisitID     int32         `json:"visit_id"`
	Address     pgtype.Text   `json:"address"`
	CountryCode pgtype.Text   `json:"country_code"`
	CountryName pgtype.Text   `json:"country_name"`
	Subdivision pgtype.Text   `json:"subdivision"`
	Continent   pgtype.Text   `json:"continent"`
	CityName    pgtype.Text   `json:"city_name"`
	Latitude    pgtype.Float8 `json:"latitude"`
	Longitude   pgtype.Float8 `json:"longitude"`
	Source      pgtype.Text   `json:"source"`
}

func (q *Queries) InsertVisitLocation(ctx context.Context, arg InsertVisitLocationParams) (VisitLocation, error) {
	row := q.db.QueryRow(ctx, insertVisitLocation,
		arg.VisitID,
		arg.Address,
		arg.CountryCode,
		arg.CountryName,
		arg.Subdivision,
		arg.Continent,
		arg.CityName,
		arg.Latitude,
		arg.Longitude,
		arg.Source,
	)
	var i VisitLocation
	err := row.Scan(
		&i.VisitID,
		&i.Address,
		&i.CountryCode,
		&i.CountryName,
		&i.Subdivision,
		&i.Continent,
		&i.CityName,
		&i.Latitude,
		&i.Longitude,
		&i.Source,
	)
	return i, err
}

const listStatisticsPerAuthor = `-- name: ListStatisticsPerAuthor :many
SELECT
	count(v.id) as nr_visits,
	MIN(u.id)::INTEGER as id,
	u.short_url as short_url,
	MIN(u.title):: TEXT as title,
	MIN(u.long_url):: TEXT as long_url,
	MIN(u.created_at)::TIMESTAMP as created_at
FROM
	urls u
LEFT JOIN visits v ON u.id = v.url_id
WHERE
	u.author_id = $1
	AND (
		$2 = ''
		-- OR to_tsvector(regexp_replace(long_url, '^(https?://)?(www\.)?', '', 'i')) @@ to_tsquery(@search)
		OR long_url ILIKE '%' || $2 || '%'
	)
GROUP BY
	u.short_url, u.id
ORDER BY
	u.id DESC
`

type ListStatisticsPerAuthorParams struct {
	AuthorID int32       `json:"author_id"`
	Search   interface{} `json:"search"`
}

type ListStatisticsPerAuthorRow struct {
	NrVisits  int64            `json:"nr_visits"`
	ID        int32            `json:"id"`
	ShortUrl  string           `json:"short_url"`
	Title     string           `json:"title"`
	LongUrl   string           `json:"long_url"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) ListStatisticsPerAuthor(ctx context.Context, arg ListStatisticsPerAuthorParams) ([]ListStatisticsPerAuthorRow, error) {
	rows, err := q.db.Query(ctx, listStatisticsPerAuthor, arg.AuthorID, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListStatisticsPerAuthorRow{}
	for rows.Next() {
		var i ListStatisticsPerAuthorRow
		if err := rows.Scan(
			&i.NrVisits,
			&i.ID,
			&i.ShortUrl,
			&i.Title,
			&i.LongUrl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVisits = `-- name: ListVisits :many
SELECT id, url_id, visited_at, ip_address, user_agent, browser_id, referrer
FROM visits
ORDER BY id DESC
`

func (q *Queries) ListVisits(ctx context.Context) ([]Visit, error) {
	rows, err := q.db.Query(ctx, listVisits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Visit{}
	for rows.Next() {
		var i Visit
		if err := rows.Scan(
			&i.ID,
			&i.UrlID,
			&i.VisitedAt,
			&i.IpAddress,
			&i.UserAgent,
			&i.BrowserID,
			&i.Referrer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const locationDistribution = `-- name: LocationDistribution :many
SELECT
    vl.country_name,
    count(vl.visit_id) AS visit_count,
    (count(vl.visit_id) * 100.0 / total_visits.total)::float AS percentage
FROM
    visit_locations vl
JOIN
    visits v ON vl.visit_id = v.id
JOIN
    urls u ON v.url_id = u.id
CROSS JOIN (SELECT count(*) as total FROM visits WHERE visits.url_id = $1) AS total_visits
WHERE
	u.author_id = $2
AND
    u.id = $1 -- Replace 'your_short_url' with the actual short URL
GROUP BY
    vl.country_name, total_visits.total
ORDER BY
    visit_count DESC
`

type LocationDistributionParams struct {
	UrlID    int32 `json:"url_id"`
	AuthorID int32 `json:"author_id"`
}

type LocationDistributionRow struct {
	CountryName pgtype.Text `json:"country_name"`
	VisitCount  int64       `json:"visit_count"`
	Percentage  float64     `json:"percentage"`
}

// SQL query to get the location distribution data for a specific URL
func (q *Queries) LocationDistribution(ctx context.Context, arg LocationDistributionParams) ([]LocationDistributionRow, error) {
	rows, err := q.db.Query(ctx, locationDistribution, arg.UrlID, arg.AuthorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LocationDistributionRow{}
	for rows.Next() {
		var i LocationDistributionRow
		if err := rows.Scan(&i.CountryName, &i.VisitCount, &i.Percentage); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const referrerDistribution = `-- name: ReferrerDistribution :many
SELECT
    v.referrer AS source,
    count(v.id) AS click_count,
    (count(v.id) * 100.0 / total_visits.total)::float AS percentage
FROM
    visits v
JOIN
    urls u ON v.url_id = u.id
CROSS JOIN (
    SELECT count(*) AS total
    FROM visits
    WHERE visits.url_id = $1
) AS total_visits
WHERE
    u.author_id = $2
AND
    u.id = $1
AND 
    v.referrer IS NOT NULL AND v.referrer != '' -- Exclude empty or null referrers
GROUP BY
    v.referrer, total_visits.total
ORDER BY
    click_count DESC
`

type ReferrerDistributionParams struct {
	UrlID    int32 `json:"url_id"`
	AuthorID int32 `json:"author_id"`
}

type ReferrerDistributionRow struct {
	Source     pgtype.Text `json:"source"`
	ClickCount int64       `json:"click_count"`
	Percentage float64     `json:"percentage"`
}

func (q *Queries) ReferrerDistribution(ctx context.Context, arg ReferrerDistributionParams) ([]ReferrerDistributionRow, error) {
	rows, err := q.db.Query(ctx, referrerDistribution, arg.UrlID, arg.AuthorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReferrerDistributionRow{}
	for rows.Next() {
		var i ReferrerDistributionRow
		if err := rows.Scan(&i.Source, &i.ClickCount, &i.Percentage); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const statisticPerURL = `-- name: StatisticPerURL :one
SELECT
	count(v.id) as nr_visits,
	MIN(u.id)::INTEGER as id,
	u.short_url as short_url,
	MIN(u.title):: TEXT as title,
	MIN(u.long_url):: TEXT as long_url,
	MIN(u.created_at)::TIMESTAMP as created_at
FROM
	urls u
LEFT JOIN visits v ON u.id = v.url_id
WHERE
	u.short_url = $1
	AND u.author_id = $2
GROUP BY
	u.short_url, u.id
LIMIT 1
`

type StatisticPerURLParams struct {
	ShortUrl string `json:"short_url"`
	AuthorID int32  `json:"author_id"`
}

type StatisticPerURLRow struct {
	NrVisits  int64            `json:"nr_visits"`
	ID        int32            `json:"id"`
	ShortUrl  string           `json:"short_url"`
	Title     string           `json:"title"`
	LongUrl   string           `json:"long_url"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) StatisticPerURL(ctx context.Context, arg StatisticPerURLParams) (StatisticPerURLRow, error) {
	row := q.db.QueryRow(ctx, statisticPerURL, arg.ShortUrl, arg.AuthorID)
	var i StatisticPerURLRow
	err := row.Scan(
		&i.NrVisits,
		&i.ID,
		&i.ShortUrl,
		&i.Title,
		&i.LongUrl,
		&i.CreatedAt,
	)
	return i, err
}

const totalVisit = `-- name: TotalVisit :one
SELECT count(*)
FROM
	visits
WHERE
	url_id = $1
`

func (q *Queries) TotalVisit(ctx context.Context, urlID int32) (int64, error) {
	row := q.db.QueryRow(ctx, totalVisit, urlID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const trackRedirect = `-- name: TrackRedirect :one
INSERT INTO visits (url_id, ip_address, user_agent, browser_id, referrer)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, url_id, visited_at, ip_address, user_agent, browser_id, referrer
`

type TrackRedirectParams struct {
	UrlID     int32       `json:"url_id"`
	IpAddress pgtype.Text `json:"ip_address"`
	UserAgent pgtype.Text `json:"user_agent"`
	BrowserID pgtype.UUID `json:"browser_id"`
	Referrer  pgtype.Text `json:"referrer"`
}

func (q *Queries) TrackRedirect(ctx context.Context, arg TrackRedirectParams) (Visit, error) {
	row := q.db.QueryRow(ctx, trackRedirect,
		arg.UrlID,
		arg.IpAddress,
		arg.UserAgent,
		arg.BrowserID,
		arg.Referrer,
	)
	var i Visit
	err := row.Scan(
		&i.ID,
		&i.UrlID,
		&i.VisitedAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.BrowserID,
		&i.Referrer,
	)
	return i, err
}

const uniqueVisitCount = `-- name: UniqueVisitCount :one
SELECT 
	count(*)
FROM
	visits
WHERE
	url_id = $1
GROUP BY 
	url_id, ip_address
`

func (q *Queries) UniqueVisitCount(ctx context.Context, urlID int32) (int64, error) {
	row := q.db.QueryRow(ctx, uniqueVisitCount, urlID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const upsertBrowser = `-- name: UpsertBrowser :one
INSERT INTO browsers (name, version, platform, mobile)
VALUES ($1, $2, $3, $4)
ON CONFLICT (name, version, platform, mobile) 
DO UPDATE SET name = EXCLUDED.name
RETURNING id, name, version, platform, mobile, created_at
`

type UpsertBrowserParams struct {
	Name     string `json:"name"`
	Version  string `json:"version"`
	Platform string `json:"platform"`
	Mobile   bool   `json:"mobile"`
}

func (q *Queries) UpsertBrowser(ctx context.Context, arg UpsertBrowserParams) (Browser, error) {
	row := q.db.QueryRow(ctx, upsertBrowser,
		arg.Name,
		arg.Version,
		arg.Platform,
		arg.Mobile,
	)
	var i Browser
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Version,
		&i.Platform,
		&i.Mobile,
		&i.CreatedAt,
	)
	return i, err
}

const visitOverTime = `-- name: VisitOverTime :many
SELECT
    date_trunc($1, visited_at)::timestamp AS visit_date,
    COUNT(*) AS visit_count
FROM
    visits
WHERE
    url_id = $2
    AND visited_at BETWEEN $3 AND $4
GROUP BY
    visit_date
ORDER BY
    visit_date
`

type VisitOverTimeParams struct {
	TimeTrunc string           `json:"time_trunc"`
	UrlID     int32            `json:"url_id"`
	StartDate pgtype.Timestamp `json:"start_date"`
	EndDate   pgtype.Timestamp `json:"end_date"`
}

type VisitOverTimeRow struct {
	VisitDate  pgtype.Timestamp `json:"visit_date"`
	VisitCount int64            `json:"visit_count"`
}

func (q *Queries) VisitOverTime(ctx context.Context, arg VisitOverTimeParams) ([]VisitOverTimeRow, error) {
	rows, err := q.db.Query(ctx, visitOverTime,
		arg.TimeTrunc,
		arg.UrlID,
		arg.StartDate,
		arg.EndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VisitOverTimeRow{}
	for rows.Next() {
		var i VisitOverTimeRow
		if err := rows.Scan(&i.VisitDate, &i.VisitCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
